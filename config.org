#+TITLE: Emacs Config
#+AUTHOR: Andrew Jacobson
#+STARTUP: overview
#+STARTUP: indent
#+LANGUAGE: en

* Personal Deets
In case my emacs gets lost.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Andrew Jacobson"
        user-mail-address "andrew.isaac.jacobson@gmail.com")
#+END_SRC
* Custom File
Load auto-generated =custom.el= file from the dotemacs dir.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC
* Sane Defaults
** Form
*** UTF-8
UTF-8. UTF-8, everywhere.

#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
*** Remove cursor blink
No blink.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC
*** Tabs
Prevent tab indentation and set default tab-width.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
  (setq-default indicate-empty-lines t)
#+END_SRC
*** Show matching parens
Highlight opening/closing paren when cursor is
on/after opening/closing paren respectively.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** Show line and column number
Show the current line and column number in the mode line.

#+BEGIN_SRC emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC
*** Display line numbers
Turn on ~linum-mode~ globally.

#+BEGIN_SRC emacs-lisp
  (global-linum-mode)
#+END_SRC
*** Highlight current line
Highlight the line that the cursor is currently on. But only when
programming.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
*** Disable mouse interface
Disable all mouse interfaces since I never use them, but only for
the GUI version.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC
*** Disable the default splash screen
This disables the default startup screen. I
am replacing it with =dashboard= later anyway.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
** Function
*** Require newline at EOF
Add a newline to the end of a file on save.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
  (setq require-trailing-newline t)
#+END_SRC
*** Allow 'y' or 'n' answers
Typing 'yes' or 'no' is tedious. Tell emacs to allow 'y' and 'n' instead.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Set backup directory
Set backups and auto-save-list directories.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
*** Delete region when typing
Delete selected region when typing, like you'd expect.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
*** No bell
Shhhh.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil)
  (setq ring-bell-function 'ignore)
#+END_SRC
*** Delete trailing white space on save
Clean up superfluous white space in buffer on save.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Make it easy to edit this file
Add a function to jump straight to this file.

#+BEGIN_SRC emacs-lisp
  (defun aj/find-config ()
    "Edit `config.org' file"
    (interactive)
    (find-file
     (concat user-emacs-directory "config.org")))

  (bind-key "C-c e" 'aj/find-config)
#+END_SRC
*** Load path
Setup ~load-path~.

#+BEGIN_SRC emacs-lisp
  ;; (defun aj/expand-file-name-in-emacs-dir (name)
  ;;   "Expands NAME to an absolute path inside the `user-emacs-directory'."
  ;;   (expand-file-name name user-emacs-directory))

  ;; (add-to-list 'load-path (aj/expand-file-name-in-emacs-dir "git"))
  ;; (add-to-list 'load-path (aj/expand-file-name-in-emacs-dir "etc"))
  ;; (add-to-list 'load-path (aj/expand-file-name-in-emacs-dir "git/distel/elisp/"))
#+END_SRC
*** Use line wrapping
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC
* Theme
The most important piece of any editor configuration: A good dark theme.
I like the ~gruvbox~ themes.

#+BEGIN_SRC emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :init (load-theme 'gruvbox-dark-hard))
#+END_SRC
* Font
Tell emacs to use [[https://adobe-fonts.github.io/source-code-pro/][Source Code Pro]] as its default font.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Source Code Pro-14"))
#+END_SRC
* Darwin
Settings for MacOS.

#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type 'darwin)
    (setq mac-option-modifier 'alt)
    (setq mac-command-modifier 'meta)
    (setq mac-pass-command-to-system nil)
    (setq dired-use-ls-dired nil)
    (setq ns-use-native-fullscreen nil))
#+END_SRC
* Modeline
** Packages
*** [[https://github.com/TheBB/spaceline][spaceline]]
While I don't use Spacemacs, its mode line is
pretty nifty and works well with my theme. Let's install
and configure it here.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
    (setq spaceline-buffer-encoding-abbrev-p nil)
    (setq powerline-default-separator nil)
    (spaceline-emacs-theme))
#+END_SRC
*** [[https://github.com/lunaryorn/fancy-battery.el][fancy-battery]]
=fancy-battery= is a nice package that shows the
remaining battery usage time. We'll use it when we
are in GUI emacs. Otherwise, we will use the built-in
battery mode.

#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
    (setq fancy-battery-show-percentage t)
    (setq battery-update-interval 15)
    (if window-system
        (fancy-battery-mode 1)
      (display-battery-mode 1)))
#+END_SRC
** Clock
Tell emacs to Use the 24-hour clock and set the format for the
clock display.

#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format 1)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

Enable the clock in the mode line.

#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC
* Keybindings
A place to global keybindings.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-F" 'forward-to-word)
  (bind-key "M-B" 'backward-to-word)
#+END_SRC
* Frames, Windows & Buffers
** Functions
*** kill-focused-buffer
Kill the currently focused buffer.

#+BEGIN_SRC emacs-lisp
  (defun kill-focused-buffer ()
      (interactive)
      (kill-buffer (current-buffer)))

  (bind-key "C-x C-k"    'kill-focused-buffer)
#+END_SRC
*** toggle-window-split
Toggles the direction in which windows are split (horizontal/vertical).

#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (bind-key "C-M-]" 'toggle-window-split)
#+END_SRC
*** rotate-windows-in-frame
Rotates the windows inside the current frame in a counter-clockwise direction.

#+BEGIN_SRC emacs-lisp
  (defun rotate-windows-in-frame ()
      (interactive)
      (let ((map
             (mapcar
              (lambda (window)
                `(,window
                  ,(window-buffer
                    (next-window window))))
              (window-list))))
        (mapcar
         (lambda (window-to-buffer)
           (let ((window (car window-to-buffer))
                 (buffer (cadr window-to-buffer)))
             (select-window window)
             (switch-to-buffer buffer))) map)))

  (bind-key "C-|" 'rotate-windows-in-frame)
#+END_SRC
** Packages
*** [[https://github.com/abo-abo/ace-window][ace-window]]
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (set-face-attribute
     'aw-background-face nil :foreground "gray40")
    (set-face-attribute
     'aw-leading-char-face nil :height 200)
    ;; i prefer keys on the home row to the default 0-9
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind ("M-o" . ace-window))
#+END_SRC
* Files & Directories
** Packages
*** dired
Set up some convenient keybindings for ~dired-mode~.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :bind
    (("C-x C-d" . 'dired-jump)
     :map dired-mode-map
          ("<backspace>" . 'dired-up-directory)))
#+END_SRC

~dired-efap~ is a nice little package that let's you
*(e)dit a (f)ile (a)t (p)oint* when in ~dired-mode~.
Let's install it and configure a keybinding for it.

#+BEGIN_SRC emacs-lisp
  (use-package dired-efap
    :ensure t
    :config
    (setq dired-efap-initial-filename-selection nil)
    :bind (:map dired-mode-map ("e" . 'dired-efap)))
#+END_SRC
* Navigation & Discoverability
** Packages
*** [[https://github.com/justbur/emacs-which-key][which-key]]
~which-key~ allows for incremental keystroke discoverability.
It's a great way to manage all of Emac's keybindings without
having to remember them all! Let's install it and turn it on
globally.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config (which-key-mode 1))
#+END_SRC
*** [[https://github.com/emacs-helm/helm][helm]]
Install and configure ~helm~.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind
    ("C-x C-f" . helm-find-files)
    ("C-x C-b" . helm-buffers-list)
    ("M-x" . helm-M-x)
    ("C-S-y" . helm-show-kill-ring)
    :config
    (setq helm-split-window-in-side-p nil
          helm-autoresize-max-height 0
          helm-autoresize-min-height 40
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-echo-input-in-header-line t)
    :init
    (helm-mode 1)
    (helm-autoresize-mode 1)
    :bind (:map helm-map
                ("C-b" . helm-find-files-up-one-level)
                ("C-f" . helm-execute-persistent-action)))
#+END_SRC
*** [[https://github.com/syohex/emacs-helm-ag][helm-ag]]
Install ~helm-ag~ for use with ~ag~ ([[https://github.com/ggreer/the_silver_searcher][the silerver searcher]]).

#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :ensure t
    :after (helm)
    :config
    (setq helm-ag-fuzzy-match t))
#+END_SRC
*** [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]]
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind ("M-S" . 'helm-swoop))
#+END_SRC
*** [[https://github.com/abo-abo/swiper][swiper]]
~swiper~ is a powerful replacement for the built-in
~isearch~, which allows for fuzzy and regexp searching
in a buffer. Let's install and configure it.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    (("C-s" . swiper)
     ("C-r" . swiper)
     :map swiper-map
     ("C-*" . 'swiper-mc)
     ("C-r" . 'swiper-query-replace))
    :config
    (setq ivy-height 15))
#+END_SRC
* [[https://github.com/abo-abo/hydra][Hydra]]
Install ~hydra~ package.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC
** hydras
My hydras.

*** ag
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-ag (:color blue :hint nil)
    "
    _a_: ag              _p_: ag-project-root
    _A_: do-ag           _P_: do-ag-project-root
    _f_: ag-this-file    _b_: ag-buffers
    _F_: do-ag-this-file _B_: do-ag-buffers
  "
    ("a" helm-ag)
    ("A" helm-do-ag)
    ("f" helm-ag-this-file)
    ("F" helm-do-ag-this-file)
    ("p" helm-ag-project-root)
    ("P" helm-do-ag-project-root)
    ("b" helm-ag-buffers)
    ("B" helm-do-ag-buffers))

  (global-set-key (kbd "C-c a") 'hydra-ag/body)
#+END_SRC
*** avy
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-avy (:color blue :hint nil)
    "
    _C_: char
    _L_: line
    _S_: symbol
    _W_: word

    _q_: quit
  "
    ("C" hydra-avy-char/body)
    ("L" hydra-avy-line/body)
    ("S" hydra-avy-symbol/body)
    ("W" hydra-avy-word/body)
    ("q" nil))

  (defhydra hydra-avy-char (:color pink :hint nil)
    "
    _c_: goto-char         _l_: goto-char-in-line
    _2_: goto-char-2       _f_: goto-char-timer
    _p_: goto-char-2-above
    _n_: goto-char-2-below

    _q_: quit
  "
    ("c" avy-goto-char)
    ("2" avy-goto-char-2)
    ("p" avy-goto-char-2-above)
    ("n" avy-goto-char-2-below)
    ("l" avy-goto-char-in-line)
    ("f" avy-goto-char-timer)
    ("q" nil))

  (defhydra hydra-avy-line (:color pink :hint nil)
    "
    _w_: copy-line           _l_: goto-line
    _k_: kill-ring-save-line _p_: goto-line-above
    _K_: kill-line           _n_: goto-line-below
    _m_: move-line           _e_: goto-end-of-line

    _q_: quit
  "
    ("w" avy-copy-line)
    ("k" avy-kill-whole-line)
    ("K" avy-kill-ring-save-whole-line)
    ("m" avy-move-line)
    ("l" avy-goto-line)
    ("p" avy-goto-line-above)
    ("n" avy-goto-line-below)
    ("e" avy-goto-end-of-line)
    ("q" nil))

  (defhydra hydra-avy-symbol (:color pink :hint nil)
    "
    _1_: goto-symbol-1
    _p_: goto-symbol-1-above
    _n_: goto-symbol-1-below
  "
    ("1" avy-goto-symbol-1)
    ("n" avy-goto-symbol-1-above)
    ("p" avy-goto-symbol-1-below)
    ("q" nil "quit"))

  (defhydra hydra-avy-word (:color pink :hint nil)
    "
    _0_: goto-word-0       _P_: goto-word-1-above      _S_: goto-subword-1
    _p_: goto-word-0-above _N_: goto-word-1-below
    _n_: goto-word-0-below _f_: goto-word-or-subword-1
    _1_: goto-word-1       _s_: goto-subword-0

    _q_: quit
  "
    ("0" avy-goto-word-0)
    ("p" avy-goto-word-0-above)
    ("n" avy-goto-word-0-below)
    ("1" avy-goto-word-1)
    ("P" avy-goto-word-1-above)
    ("N" avy-goto-word-1-below)
    ("f" avy-goto-word-or-subword-1)
    ("s" avy-goto-subword-0)
    ("S" avy-goto-subword-1)
    ("q" nil))

  (global-set-key (kbd "C-c v") 'hydra-avy/body)
#+END_SRC
*** anzu
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-anzu (:color pink :hint nil)
    "
  _m_ anzu-mode: %`anzu-mode

  _f_: replace-at-cursor-thing _c_: query-replace-at-cursor
  _i_: isearch-query-replace   _t_: query-replace-at-cursor-thing
  _r_: query-replace
  _R_: query-replace-regexp

  _q_: quit
  "
    ("m" anzu-mode)
    ("f" anzu-replace-at-cursor-thing)
    ("i" anzu-isearch-query-replace)
    ("r" anzu-query-replace)
    ("R" anzu-query-replace-regexp)
    ("c" anzu-query-replace-at-cursor)
    ("t" anzu-query-replace-at-cursor-thing)
    ("q" nil))
#+END_SRC
*** help
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-help (:color blue :hint nil)
    "
  _m_: man           _c_: command     _f_: function
  _a_: apropos       _l_: library     _i_: info
  _d_: documentation _u_: user-option
  _v_: variable      _e_: value

  _q_: quit
  "
    ("m" man)
    ("a" apropos)
    ("d" apropos-documentation)
    ("v" apropos-variable)
    ("c" apropos-command)
    ("l" apropos-library)
    ("u" apropos-user-option)
    ("e" apropos-value)
    ("f" describe-function)
    ("i" helm-info)
    ("q" nil))

  (global-set-key (kbd "C-c h") 'hydra-help/body)
#+END_SRC
*** git
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-git (:color blue :hint nil)
    "
  _i_: init        _z_: stash
  _s_: status      _b_: blame
  _l_: log current _t_: git-timemachine
  _L_: log other

  _q_: quit
  "
    ("i" magit-init)
    ("s" magit-status)
    ("l" magit-log-current)
    ("L" magit-log)
    ("z" magit-stash)
    ("b" magit-blame)
    ("t" git-timemachine)
    ("q" nil))

  (global-set-key (kbd "C-c g") 'hydra-git/body)
#+END_SRC
*** window
#+BEGIN_SRC emacs-lisp
  (defun smart-find-file (arg)
    (interactive "P")
    (if (equal (projectile-project-type) nil)
        (helm-find-files arg)
      (projectile-find-file)))

  (defhydra hydra-window (:color red :hint nil)
    "
  _o_: ace-window          _0_: delete-window        _h_: windmove-left  _t_: toggle-frame-fullscreen _F_: find-file
  _d_: ace-delete-window   _1_: delete-other-windows _l_: windmove-right _b_: ido-switch-buffer
  _i_: ace-maximize-window _2_: split-window-below   _j_: windmove-down  _p_: helm-projectile
  _s_: ace-swap-window     _3_: split-window-right   _k_: windmove-up    _f_: smart-find-file

  _q_: quit
  "
    ("o" ace-window)
    ("d" ace-delete-window)
    ("s" ace-swap-window)
    ("i" ace-maximize-window :color blue)
    ("0" delete-window)
    ("1" delete-other-windows :color blue)
    ("2" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down)))
    ("3" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right)))
    ("h" windmove-left)
    ("l" windmove-right)
    ("j" windmove-down)
    ("k" windmove-up)
    ("t" toggle-frame-fullscreen)
    ("b" ido-switch-buffer)
    ("p" helm-projectile)
    ("f" smart-find-file)
    ("F" helm-find-files)
    ("q" nil))

  (global-set-key (kbd "C-c w") 'hydra-window/body)
#+END_SRC
*** move-dup
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-move-dup (:color pink)
    "Move/Dup"
    ("k" md/move-lines-up "move-up")
    ("j" md/move-lines-down "move-down")
    ("p" md/duplicate-up "dup-up")
    ("n" md/duplicate-down "dup-down")
    ("q" nil "quit"))

  (global-set-key (kbd "C-c l") 'hydra-move-dup/body)
#+END_SRC
*** selection
#+BEGIN_SRC emacs-lisp
  (defun hydra-set-mark ()
    (interactive)
    (if (region-active-p)
        (progn
          (deactivate-mark)
          (hydra-keyboard-quit))
      (call-interactively 'set-mark-command)
      (hydra-region/body)))

  (defun unset-mark ()
    (interactive)
    (if (region-active-p)
        (progn
          (deactivate-mark))))

  (defhydra hydra-region (:color pink :hint nil)
    "
  _f_: forward-word  _n_: next-line          _=_: expand-region     _<_: beginning-of-buffer _;_: comment-line
  _b_: backward-word _p_: previous-line      _-_: contract-region   _>_: end-of-buffer
  _F_: forward-sexp  _N_: forward-paragraph  _e_: end-of-line       _w_: copy
  _B_: backward-sexp _P_: backward-paragraph _a_: beginning-of-line _k_: kill

  _M_: multiple-cursors _L_: move-dup _S_: replace-string _R_: replace-regexp

  _q_: quit
  "
    ("f" forward-word)
    ("b" backward-word)
    ("F" forward-sexp)
    ("B" backward-sexp)
    ("n" next-line)
    ("p" previous-line)
    ("N" forward-paragraph)
    ("P" backward-paragraph)
    ("e" end-of-line)
    ("a" beginning-of-line)
    ("=" er/expand-region)
    ("-" er/contract-region)
    ("w" copy-region-as-kill :color blue)
    ("k" kill-region :color blue)
    ("<" beginning-of-buffer)
    (">" end-of-buffer)
    ("M" hydra-multiple-cursors/body :color blue)
    ("L" hydra-move-dup/body :color blue)
    ("S" replace-string :color blue)
    ("R" replace-regexp :color blue)
    (";" comment-line)
    ("q" nil))

  (global-set-key (kbd "C-SPC") 'hydra-set-mark)
#+END_SRC
*** toggle
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-toggle (:color pink :hint nil)
    "
    _a_ abbrev-mode:       %`abbrev-mode
    _d_ debug-on-error:    %`debug-on-error
    _f_ auto-fill-mode:    %`auto-fill-function
    _h_ highlight          %`highlight-nonselected-windows
    _t_ truncate-lines:    %`truncate-lines
    _w_ whitespace-mode:   %`whitespace-mode
    _l_ org link display:  %`org-descriptive-links
    _r_ rainbow-mode:      %`rainbow-mode

    _q_: quit
    "
    ("a" abbrev-mode)
    ("d" toggle-debug-on-error)
    ("f" auto-fill-mode)
    ("h" (setq highlight-nonselected-windows (not highlight-nonselected-windows)))
    ("t" toggle-truncate-lines)
    ("w" whitespace-mode)
    ("l" org-toggle-link-display)
    ("r" rainbow-mode)
    ("q" nil))

  ;; toggle `whitespace-mode' to inhibit first run error
  (whitespace-mode)
  (whitespace-mode)
  ;; toggle `rainbow-mode' to inhibit first run error
  (rainbow-mode)
  (rainbow-mode)
  (global-set-key (kbd "C-c t") 'hydra-toggle/body)
#+END_SRC
*** search-and-replace
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-search-and-replace (:color blue :hint nil)
    "
    _a_: anzu           _r_: vr/replace
    _d_: deadgrep       _R_: vr/query-replace
    _i_: symbol-overlay
    _e_: iedit

    _q_: quit
    "
    ("a" hydra-anzu/body)
    ("d" deadgrep)
    ("i" symbol-overlay-put)
    ("e" iedit-mode)
    ("r" vr/replace)
    ("R" vr/query-replace)
    ("q" nil))

  (global-set-key (kbd "C-c s") 'hydra-search-and-replace/body)
#+END_SRC
*** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-multiple-cursors (:color pink)
    "Multiple Cursors"
    ("a" mc/mark-all-like-this-dwim "mark-all")
    ("n" mc/mark-next-like-this "mark-next")
    ("p" mc/unmark-next-like-this "unmark-next")
    ("q" nil "quit"))

  ;; (global-set-key (kbd "C-c m") 'hydra-multiple-cursors/body)
#+END_SRC
* Text Editing
** Functions
*** previous-indent-and-open-newline
#+BEGIN_SRC emacs-lisp
  (defun previous-indent-and-open-newline ()
      "Call `indent-and-open-newline' with non-nil PREVIOUS value"
      (interactive)
      (indent-and-open-newline t))

  (bind-key "C-o" 'previous-indent-and-open-newline)
#+END_SRC
*** indent-and-open-newline
#+BEGIN_SRC emacs-lisp
  (defun indent-and-open-newline (&optional previous)
      "Add a newline after current line and tab to indentation.
      If PREVIOUS is non-nil, go up a line first."
      (interactive)
      (if previous
          (previous-line))
      (end-of-line)
      (newline)
      (indent-for-tab-command))

  (bind-key "C-M-o" 'indent-and-open-newline)
#+END_SRC
** Packages
*** [[https://github.com/syohex/emacs-anzu][anzu]]
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :config
    (global-anzu-mode))
#+END_SRC
*** [[https://github.com/abo-abo/avy][avy]]
~avy~ provides a nice jump-to-char mechanic which is
useful for hopping around buffers.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("C-:" . 'avy-goto-char)
    ("C-'" . 'avy-goto-char-2)
    ("M-g f" . 'avy-goto-line)
    ("M-g w" . 'avy-goto-word-1)
    ("M-g e" . 'avy-goto-word-0))
#+END_SRC
*** [[https://github.com/magnars/expand-region.el][expand-region]]
From the GitHub page:

/Expand region increases the selected region by semantic units.
Just keep pressing the key until it selects what you want./

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure
    :bind ("C-=" . 'er/expand-region))
#+END_SRC
*** [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]
~multiple-cursors~ let's you have, well, more than 1 cursor.
This is especially useful for making similar multi-line edits
in one go, or for changing the same named symbol in a buffer.

Let's install it and setup some keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind
    ("C-c C-m" . 'mc/mark-all-dwim)
    ("C-+" . 'mc/mark-next-like-this)
    ("C-_" . 'mc/unmark-next-like-this))
#+END_SRC
*** [[https://github.com/wyuenho/move-dup][move-dup]]
~move-dup~ let's you easily move lines and regions around
inside a buffer. It also makes duplicating single lines up or
down a breeze. Let's install it and add some keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package move-dup
    :ensure t
    :bind
    ("C-S-p" . 'md/move-lines-up)
    ("C-S-n" . 'md/move-lines-down)
    ("M-P" . 'md/duplicate-up)
    ("M-N" . 'md/duplicate-down))
#+END_SRC
*** [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]
~wgrep~ is a writable grep buffer, which I mainly use to do
quick text replacement after grepping in a file or project.

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :config (setq wgrep-auto-save-buffer t))
#+END_SRC
*** [[https://github.com/wolray/symbol-overlay][symbol-overlay]]
Install ~symbol-overlay~.

#+BEGIN_SRC emacs-lisp
  (use-package symbol-overlay
    :ensure t)
#+END_SRC
*** [[https://github.com/benma/visual-regexp.el][visual-regexp]]

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :ensure t)
#+END_SRC
*** [[https://github.com/tsdh/iedit][iedit]]
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t)
#+END_SRC
*** [[https://github.com/Wilfred/deadgrep][deadgrep]]
#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :ensure t)
#+END_SRC
*** [[https://github.com/mickeynp/smart-scan][smartscan]]
#+BEGIN_SRC emacs-lisp
  (use-package smartscan
    :ensure t
    :config (global-smartscan-mode t))
#+END_SRC
* Project Management
** Packages
*** [[https://github.com/bbatsov/projectile][projectile]]
~projectile~ tracks projects in emacs and allows us to to handy things
like: switching between files in a project or grepping all files within
a project. Very useful. Let's install it now.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-global-mode 1)
    :bind (:map projectile-mode-map
                ("C-c p" . 'projectile-command-map)))
#+END_SRC
*** [[https://github.com/bbatsov/helm-projectile][helm-projectile]]
A ~helm~ front-end for ~projectile~, allowing incremental
completion for ~projectile~ commands. Let's install and configure it.

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after (projectile)
    :ensure t
    :config
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))
#+END_SRC
* Git
** Packages
*** [[https://github.com/magit/magit][magit]]
~magit~ is the best git front-end. Ever. Plain and simple.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC
*** [[https://gitlab.com/pidu/git-timemachine][git-timemachine]]
A neat package that allows you to step forward and backward
in time for the git history of a specific file.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC
* Programming
** General
*** [[https://github.com/Fuco1/smartparens][smartparens]]
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (use-package smartparens-config)
    (smartparens-global-mode 1))
#+END_SRC
*** rainbow-mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :hook
    ((prog-mode org-mode lisp-interaction-mode) . rainbow-mode))
#+END_SRC
*** [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook
    ((lisp-mode emacs-lisp-mode lisp-interaction-mode org-mode) . rainbow-delimiters-mode))
#+END_SRC
*** [[https://github.com/kyagi/shell-pop-el][shell-pop]]
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind (("C-." . shell-pop))
    :config
    (setq shell-pop-shell-type
          (quote ("ansi-term" "*ansi-term*"
                  (lambda nil (ansi-term shell-pop-term-shell)))))
    (setq shell-pop-term-shell "/bin/zsh")
    ;; need to do this manually or not picked up by `shell-pop'
    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC
*** [[https://github.com/pashky/restclient.el][restclient]]
#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure
    :mode (("\\.http\\'" . restclient-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar http-buffer "*http*")
  (defvar initial-http-message "# -*- restclient -*-\n#\n\n")

  (defun aj/get-http-buffer-create ()
    (interactive)
    (let ((buf (get-buffer http-buffer)))
      (if (null buf)
          (progn
            (switch-to-buffer-other-window http-buffer)
            (restclient-mode)
            (insert initial-http-message))
        (switch-to-buffer-other-window http-buffer))))
#+END_SRC
** Functions
*** shell
Run a =zsh= instance.

#+BEGIN_SRC emacs-lisp
  (defun aj/zsh ()
    "Run a `zsh' instance."
    (interactive)
    (ansi-term "/bin/zsh"))

  (global-set-key (kbd "C-c .") 'aj/zsh)
#+END_SRC
** Snippets
** Completion
*** Company
~company-mode~ is my preferred completion engine. Let's
install it and do some basic configuration.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    ;; no delay before showing completion candidates
    (setq company-idle-delay 0)
    ;; show completion candidates after 3 chars are typed
    (setq company-minimum-prefix-length 3)
    :bind
    (:map company-active-map
          ("M-n" . nil)
          ("M-p" . nil)
          ("C-n" . 'company-select-next)
          ("C-j" . 'company-select-next)
          ("C-p" . 'company-select-previous)
          ("C-k" . 'company-select-previous)
          ("C-f" . 'company-filter-candidates)))
#+END_SRC
** Linting
*** [[https://github.com/flycheck/flycheck][flycheck]]
Install ~flycheck~.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC
** Languages
*** Elixir
**** Packages
***** [[https://github.com/tonini/alchemist.el][alchemist]]
~alchemist~ is an IDE-like set of tools built around
Elixir. Let's install it now.

#+BEGIN_SRC emacs-lisp
  (use-package alchemist
    :ensure t)
#+END_SRC
**** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook
   'elixir-mode-hook
   (lambda ()
     (add-hook 'before-save-hook 'elixir-format)))
#+END_SRC
**** Completion
Enable ~company-mode~ for all Elixir modes.

#+BEGIN_SRC emacs-lisp
  (add-hook 'elixir-mode-hook 'company-mode)
  (add-hook 'alchemist-iex-mode-hook 'company-mode)
#+END_SRC
*** Lisp
**** [[https://github.com/abo-abo/lispy][lispy]]
I'm trying out ~lispy~, a package similar to ~paredit~ but
with short, magical keybindings. Let's install it and enable
it for lisp languages.

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :ensure t
    :hook
    (lisp-mode . lispy-mode)
    (emacs-lisp-mode . lispy-mode)
    :bind
    (:map lispy-mode-map
          ("`" . 'self-insert-command)
          ("M-o" . 'ace-window)))
#+END_SRC
**** [[https://github.com/slime/slime][slime]]
*(S)uperior (L)isp (I)nteraction (M)ode for (E)macs* is a
collection of handy tools that can be used with a range of
lisp implementations. Let's install it now.

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/local/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))
#+END_SRC
**** Dialects
***** Emacs Lisp (elisp)
****** TODO Snippets
****** Completion
Enable ~company-mode~ for ~emacs-lisp-mode~.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)
#+END_SRC
****** TODO Linting
***** Common Lisp
****** TODO Snippets
****** Completion
Enable ~company-mode~ for ~lisp-mode~.

#+BEGIN_SRC emacs-lisp
  (add-hook 'lisp-mode-hook 'company-mode)
#+END_SRC
****** TODO Linting
*** TypeScript
**** Packages
***** [[https://github.com/emacs-typescript/typescript.el][typescript-mode]]
The major mode for editing ~typescript~ files.

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-mode)))
#+END_SRC
***** [[https://github.com/ananthakumaran/tide/][tide]]
~tide~ or *(T)ypeScript (I)nteractive (D)evelopment (E)nvironment*
is a set of tools that add IDE-like features for TypeScript
projects. Let's install and configure it now.

#+BEGIN_SRC emacs-lisp
  (use-package tide
    :ensure t
    :after (typescript-mode)
    :hook
    (typescript-mode .
     (lambda ()
       (setq flycheck-check-syntax-automatically '(save mode-enabled))
       (tide-setup)
       (tide-hl-identifier-mode 1)
       (eldoc-mode 1))))
#+END_SRC
**** Linting
#+BEGIN_SRC emacs-lisp
  (add-hook 'typescript-mode-hook 'flycheck-mode)
#+END_SRC
**** Completion
#+BEGIN_SRC emacs-lisp
  (add-hook 'typescript-mode-hook 'company-mode)
#+END_SRC
*** Python
**** Packages
[[https://github.com/jorgenschaefer/elpy][elpy]]
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :config (elpy-enable))
#+END_SRC
*** JavaScript
**** Packages
***** [[https://github.com/mooz/js2-mode][js2-mode]]
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode (("\\.js\\'" . js2-mode)))
#+END_SRC
***** [[https://github.com/magnars/js2-refactor.el][js2-refactor]]
#+BEGIN_SRC emacs-lisp
  (use-package js2-refactor
    :ensure t
    :hook (js2-mode . js2-refactor-mode)
    :config (js2r-add-keybindings-with-prefix "C-c C-r")
    :bind (:map js2-mode-map
                ("C-k" . 'js2r-kill)))
#+END_SRC
***** [[https://github.com/NicolasPetton/xref-js2][xref-js2]]
#+BEGIN_SRC emacs-lisp
  (use-package xref-js2
    :ensure t
    :bind (:map js2-mode-map
                ("M-." . nil))
    :hook (js2-mode
           . (lambda ()
               (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))
#+END_SRC
**** Completion
***** [[https://github.com/proofit404/company-tern][company-tern]]
#+BEGIN_SRC emacs-lisp
  (use-package company-tern
    :ensure t
    :hook (js2-mode .
                    (lambda ()
                      (add-to-list 'company-backends 'company-tern)
                      (company-mode)
                      (tern-mode))))
#+END_SRC
**** Linting
**** Snippets
